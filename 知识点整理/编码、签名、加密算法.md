[TOC]

# 编码算法

## URL编码
URL编码：将任意文本数据转换成application/x-www-form-urlencoded字符串，即ASCII码中的安全字符（没有特殊用途的可打印字符）。

编码规则：
> 1. 字符"a"-"z"、"A"-"Z"、"0"-"9"、"."、"-"、"*"和"_" 都不会被编码；
> 2. 将空格转换为加号 (+) ；
> 3. 将非文本内容转换成"%xy"的形式,xy是两位16进制的数值；
> 4. 在每个 name=value 对之间放置 & 符号。

```java
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public class Test {
    public static void main(String[] args) throws UnsupportedEncodingException {
        String urlParameter = "url参数";
        String encode = URLEncoder.encode(urlParameter, "UTF-8");
        System.out.println(encode);  // url%E5%8F%82%E6%95%B0
        String decode = URLDecoder.decode(encode, "UTF-8");
        System.out.println(decode);  // url参数
    }
}
```

### 为什么要进行url编码
① 解决url带参时的歧义
http协议中，以application/x-www-form-urlencoded方式提交的请求会将参数以"key=value"键值对的方式传输，并用"&"分割不同的参数。

因此如果参数带上"="或者"&"会导致服务器解析错误。

此外，某些特殊的符号在不同的系统中可能有特殊的含义。

② 解决同一个字符在不同编码集或操作系统的差异性

## Base64编码
base64编码：将任意的二进制数据，包括文件、图片等转化为64个可打印字符。

可打印字符串包括："A-Z"、"a-z"、"0-9"、"+"、"/"共64个。

编码规则：
> 1. 将每3字节为一组划分原始字符串，即每组24位。
> 2. 将上述24位数据分成4组，每组6位，并在最高位补两个0凑足一个字节。
> 3. 这样就把一个3字节数据重新编码成4字节，与64个可打印字符一一对应。
> 4. 如果划分原始字符串时，最后一组不够3个字节的需要补一个或两个0，并在编码后的字符串补充一个或两个的等号(=)。

base64编码会使数据量增加1/3，效率降低，但适用于文本协议，如HTTP协议。

一般在对重要数据进行传输时，需要先对原始数据进行Base64转码，再进行签名或加密。

```java
import java.io.UnsupportedEncodingException;
import java.util.Base64;

public class Test {
    public static void main(String[] args) throws UnsupportedEncodingException {
        String text = "一张图片.jpg";
        String encode = Base64.getEncoder().encodeToString(text.getBytes("UTF-8"));
        System.out.println(encode);  // 5LiA5byg5Zu+54mHLmpwZw==
        byte[] decodes = Base64.getDecoder().decode(encode);
        String decode = new String(decodes, "utf-8");
        System.out.println(decode);  // 一张图片.jpg
    }
}
```
# 加密
## 对称加密
Symmetric-key algorithm：加密和解密使用相同的密钥。
|   名称   |  密钥长度    |   安全性   |   运行速度   |   资源消耗   |
| ----    | ----        | ----      | ----        | ----       |
|   DES   |   64位      |   低       |   较快      |   中        |
|   3DES  |   116、168位   |   中   |   慢   |   高   |
|   AES   |   128、192、256位   |   高   |   快   |   低   |

对称加密算法：算法名称 / 工作模式（ECB、CBC、PCBC…）/填充模式（NoPadding、PKCS5Padding、PKCS7Padding…）

参考网址：https://www.jianshu.com/p/f8cd7391d641

### DES
Data Encryption Standard（美国数据加密标准）：1972年IBM公司发明，适用于加密大量数据的场合。

明文按64位进行分组，密钥长56位（还有8位校验位）。

### AES 
Advanced Encryption Standard（高级加密标准）：又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。用来取代DES，具有更好的安全性、效率和灵活性。

```java
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

public class AesUtil {
    private static final Logger logger = LoggerFactory.getLogger(AesUtil.class);

    /**
     * 密钥
     */
    private static final String AES_SECRET_KEY = "aes_secret_key";
    /**
     * 算法名称/工作模式/填充模式
     */
    private static final String AES_ENCRYPTION_TYPE = "AES/CBC/PKCS5Padding";

    private static SecretKeySpec keySpec;
    private static IvParameterSpec ivSpec;

    static {
        byte[] secretKeyBytes = AES_SECRET_KEY.getBytes();
        keySpec = new SecretKeySpec(secretKeyBytes, "AES");
        ivSpec = new IvParameterSpec(secretKeyBytes);
    }

    /**
     * AES 加密
     *
     * @param plainText 明文
     * @return 密文
     */
    public static String encrypt(String plainText) {
        if (StringUtils.isEmpty(plainText)) {
            return null;
        }
        try {
            Cipher cipher = Cipher.getInstance(AES_ENCRYPTION_TYPE);
            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
            byte[] cipherTextBytes = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
            return new String(Base64.getEncoder().encode(cipherTextBytes));
        } catch (Exception e) {
            logger.error("aes加密报错：{}", e);
        }
        return null;
    }

    /**
     * AES 解密
     *
     * @param cipherText 密文
     * @return 明文
     */
    public static String decrypt(String cipherText) {
        if (StringUtils.isEmpty(cipherText)) {
            return null;
        }
        byte[] cipherTextBytes = Base64.getDecoder().decode(cipherText);
        try {
            Cipher cipher = Cipher.getInstance(AES_ENCRYPTION_TYPE);
            cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
            byte[] plainTextBytes = cipher.doFinal(cipherTextBytes);
            return new String(plainTextBytes, StandardCharsets.UTF_8);
        } catch (Exception e) {
            logger.error("aes解密报错：{}", e);
        }
        return null;
    }
}
```

## 非对称加密
非对称加密算法是一种密钥的保密方法。 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。 使用公开密钥对数据进行加密，用对应的私有密钥进行解密。

|   名称   |  成熟度    |   安全性   |   运算速度   |   资源消耗   |
| ----    | ----      | ----      | ----        | ----       |
|   RSA   |   高      |   高       |   中        |   中        |
|   DSA   |         |          |           |           |
|   ECC   |   高      |   高       |   慢        |   高        |

### RSA
1977年，由三位数学家Rivest、Shamir 和 Adleman 设计。核心内容在于对极大整数进行因式分解。RSA算法非常可靠，密钥越长，它就越难破解。

#### 原理
参考网站：http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html
> 1. 随机选择两个质数：p=61，q=53。
> 2. 计算p和q的乘积：n=p\*q=61*53=3233。
> 3. 计算n的欧拉函数：φ(n)=(p-1)(q-1)=60*52=3120。
> 4. 随机选取一个小于φ(n)，且与φ(n)互质的整数：e=17
> 5. 计算e对于φ(n)的模反元素：d=2753。
> 6. n和e封装成公钥，n和d封装成私钥。
> 7. 假设发送内容为m，则发送的密文：c=m^e%n。
> 8. 接收到密文后c后，解密：m=c^d%n。

实际使用中可以认为，n取1024位（二进制位）基本安全，2048位极其安全。e常取65537。

m为小于n的整数，如果m大于n，则需要将消息分成若干段分别加密，或者先用其他的如DES进行加密处理，再使用RSA。

可靠性分析：任何人获取公钥后，就算破解了n和e，也要将n因式分解，才能计算出φ(n)，从而计算出d。因此RSA算法的破解难点在于极大整数的因式分解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，目前没有任何可靠的方法可以破解。



### DSA
Digital Signature Algorithm，数字签名算法，是一种标准的 DSS（数字签名标准）

### ECC
Elliptic Curves Cryptography（椭圆曲线密码编码学）：基于椭圆曲线数学。

ECC的主要优势是在某些情况下它比其他的方法（比如RSA）使用更小的密钥，提供相当的或更高等级的安全。
ECC的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。
不过一个缺点是加密和解密操作的实现比其他机制花费的时间长，更耗CPU资源。

代码：https://blog.csdn.net/baidu_22254181/article/details/82594072

## 对称算法与非对称算法优缺点对比
对称算法：
> 1. 密钥管理麻烦，不适合互联网系统，一般用于内部系统。
> 2. 安全性：中
> 3. 加密速度：软件加密速度至少快100倍，每秒可以加密数兆比特数据，适合大数据量的加解密处理。

非对称算法：
> 1. 密钥容易管理。
> 2. 安全性：高。
> 3. 加密速度：比较慢，适合小数据量加解密，或数据签名。

# 签名
签名算法：指数字签名算法，又称为公钥数字签名、电子签章。不需要密钥。

目前应用最广泛的是Hash签名、DSA签名、RSA签名。
## Hash签名（摘要算法）
|   名称   |  散列值长度  |  散列值长度  |安全性   |   速度  |
| ----    | ----       | ----        | ----   | ----   |
|  MD5    |  128bit    |  32位16进制  |   中   |   快    |
|  SHA-1  |  160bit    |  40位16进制  |   高   |   慢    |
|  SHA-256  |  256bit  |  32字节      | | |
|  SHA-512  |  512bit  |  64字节      | | |

### MD5
Message Digest algorithm 5（消息摘要算法）

输入任意大小、格式的文件，输出128 bit（16 字节，通常用16进制表示为32个字符）的散列值。一个文本修改任何一个字符，产生的MD5值是不同的。常用于校验信息是否被篡改。

使用哈希函数进行散列，极端情况下，可能出现哈希碰撞。

```java
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

/**
 * @author 陌上丶天琊
 * @date 2019-11-21 15:39
 * 描述：摘要算法工具
 */
public class DigestUtil {
    /**
     *
     * @param content 原始数据
     * @return md5签名
     */
    public static String computeMD5(String content) {
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            byte[] bytes = md5.digest(content.getBytes());
            // 转化成32位的16进制字符串，
            return String.format("%032x", new BigInteger(1, bytes));
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
}
```
### SHA家族
是一个密码散列函数家族，是 FIPS （美国国家安全局）所认证的安全散列算法。
```java
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

/**
 * @author 陌上丶天琊
 * @date 2019-11-21 15:39
 * 描述：摘要算法工具
 */
public class DigestUtil {
    /**
     *
     * @param content 原始数据
     * @return sha-1签名
     */
    public static String computeSHA1(String content) {
        try {
            MessageDigest md5 = MessageDigest.getInstance("SHA-1");
            md5.update(content.getBytes());
            byte[] bytes = md5.digest();
            // 转化成40位的16进制字符串，
            return String.format("%040x", new BigInteger(1, bytes));
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
}
```
### HMAC
Hash Message Authentication Code（散列消息鉴别码）

利用哈希算法 (MD5、SHA1 等)，输入一个密钥和 一个消息，输出一个消息摘要。发送方和接收方都需要密钥才能进行散列值的计算。

```java
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

/**
 * @author 陌上丶天琊
 * @date 2019-11-21 15:39
 * 描述：摘要算法工具
 */
public class DigestUtil {
    /**
     * 密钥
     */
    private static final String HMAC_SECRET_KEY = "key";
    /**
     * MAC算法有：HmacMD5/HmacSHA1/HmacSHA256/HmacSHA384/HmacSHA512
     */
    private static final String HMAC_ENCRYPTION_TYPE = "HmacMD5";
    private static final SecretKey SECRET_KEY = new SecretKeySpec(HMAC_SECRET_KEY.getBytes(StandardCharsets.UTF_8),HMAC_ENCRYPTION_TYPE);

    /**
     * @param content 原始数据
     * @return HMAC签名
     */
    public static String computeHMAC(String content) {
        try {
            Mac mac = Mac.getInstance(SECRET_KEY.getAlgorithm());
            mac.init(SECRET_KEY);
            byte[] bytes = mac.doFinal(content.getBytes());
            return String.format("%032x", new BigInteger(1, bytes));
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e.getMessage());
        } catch (InvalidKeyException e2) {
            throw new RuntimeException(e2.getMessage());
        }
    }
}
```
## RSA签名
代码：https://blog.csdn.net/yangwei234/article/details/85006685#_161

## DSA签名算法
代码：https://blog.csdn.net/yangwei234/article/details/85006685#_161

# 编码、签名、加密的区别

编码：为了满足某种传输格式的要求，将一段内容从某种编码格式转换为另一种编码，如URL编码、Base64编码、hex编码等。转码过程是独立的，不需要借助额外的内容。
加密：为了信息安全，将传输内容进行转码。与编码不用的是需要借助加密密钥。
签名：用一份简短的内容来检查一份很长的内容是否正确。比如MD5算法，可以将1GB的文件生成一个32字节长的MD5签名。而且这个文件一旦改了任何一个字符，再次生成的MD5就会不一样。

编码和加密的转换过程是可逆的，转码前和转码后的内容可以互相转化，唯一区别是加密需要借助公私钥。

签名是不可逆的，即拿到一个32字节的签名并不能重新还原成一个1GB的文件。也不需要密钥。

因此：签名是用来防止数据篡改的，而加密是用来防止信息泄露，即使传输的数据被人截取，但是只要加密算法和密钥不泄露，就不知道原始数据。而编码主要是按照某种格式要求传输数据的，虽然可以转换成人眼不识别的字符串，但因为算法简单，很容易破解，一般不用作加密。

实际使用中，对信息安全要求较高的系统，常常编码、签名、加密组合使用。
















