synchronized的底层实现

JDK早期的 重量级 - OS（向操作系统申请）

后来的改进
锁升级的概念：
    我就是厕所所长 （一 二）

synchronized (object)               -- 锁住某个对象
markword 记录这个线程ID （偏向锁）  -- 第一个线程访问该对象时，只记录了这个线程的id
如果线程争用：升级为 自旋锁         -- 第二个线程来申请访问时，CPU进行类似轮询的操作去等待加锁
10次以后，升级为系统锁（重量级锁）  -- 默认轮询十次后，仍然得不到锁才向OS申请加锁

自旋锁只在用户态进行操作，只占用CPU资源
而访问操作系统不需要占用CPU资源，但加解锁需要切换到内核态


执行时间短（加锁代码），线程数少，用自旋锁
执行时间长，线程数多，用系统锁


不能给String、Integer、Long等加synchronized锁。