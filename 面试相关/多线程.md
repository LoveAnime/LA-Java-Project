[toc]

参考网址：https://blog.csdn.net/ll666634/article/details/78615505
含实现代码

## 1、现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？
解析：检测你对“join”方法是否熟悉。

## 2、在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？
- synchronized是独占锁，别的线程只能等待，程序执行效率低；读写操作会发生冲突，IO堵塞。
- Lock在线程等待获取锁时可以响应中断，不会一直等待；多个线程可以同时进行读操作。
- synchronized是同步的；Lock可以实现异步。
- synchronized在线程执行完毕会自动释放对锁的占用；但是Lock不会，需要主动释放，或则可能出现死锁现象。
- synchronized只支持非公平锁；Lock实现类基本都支持非公平锁（默认）和公平锁。当然，在大部分情况下，非公平锁是高效的选择。

整体上来说Lock是synchronized的扩展版，也更轻量级，但现代JVM一直在对对synchronized进行优化，低并发下并看不出性能上的差异。
```java
public interface Lock {
    // 无条件加锁
    void lock();
    // 可中断锁
    void lockInterruptibly() throws InterruptedException;
    // 可轮询的加锁
    boolean tryLock();
    // 定时锁
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    // 可多条件队列的锁
    Condition newCondition();
}
 
public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}
```
ReadWriteLock是对Lock的运用，可以使用ReentrantReadWriteLock类实现读写类型的高效缓存 。

## 3、在java中wait和sleep方法的不同？
最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。

- Java的多线程锁是挂在对象上的，并不是在方法上的。即每个对象都有一个锁，当遇到类似synchronized的同步需要时，就会监视(monitor)每个想使用本对象的线程按照一定的规则来访问，规则也就是在同一时间内只能有一个线程能访问此对象。
- Java中获取锁的单位是线程。当线程A获取了对象B的锁，也就是对象B的持有标记上写的是线程A的唯一标识，在需要同步的情况下的话，只有线程A能访问对象B。
- Thread常用方法有：start/stop/yield/sleep/interrupt/join等，他们是线程级别的方法，所以并不会太关心锁的具体逻辑。
- Object的线程有关方法是：wait/wait(事件参数)/notify/notifyAll，他们是对象的方法，所以使用的时候就有点憋屈了，必须当前线程获取了本对象的锁才能使用，否则会报异常。但他们能更细粒度的控制锁，可以释放锁。

## 4、用Java实现阻塞队列？
 用wait()和notify()方法来实现阻塞队列。

## 5、BlockingQueue接口
BlockingQueue的实现大多是通过 lock锁的多条件（condition）阻塞控制

BlockingQueue的实现类：ArrayBlockingQueue、DelayQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue

## 6、用Java写代码来解决生产者——消费者问题
实现方法：
- 用wait() / notify()方法
- 用Lock的多Condition方法
- BlockingQueue阻塞队列方法
- CyclicBarrier、CountDownLatch

## 7、用Java写一个会导致死锁的程序，你将怎么解决？
产生死锁的四个必要条件： 
- 互斥条件：一个资源每次只能被一个进程使用。 
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
- 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。 
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

如何避免死锁？ 从死锁的四个必要条件来看，破坏其中的任意一个条件就可以避免死锁。
- 互斥条件是由资源本身决定的，不剥夺条件一般无法破坏，要实现的话得自己写更多的逻辑。 
- 避免无限期的等待：用lock.tryLock()、object.wait()/notify()等方法写出请求一定时间后，放弃已经拥有的锁的程序。 
- 注意锁的顺序：以固定的顺序获取锁，可以避免死锁。 
- 开放调用：即只对有请求的进行封锁。你应当只想你要运行的资源获取封锁，比如在上述程序中我在封锁的完全的对象资源。但是如果我们只对它所属领域中的一个感兴趣，那我们应当封锁住那个特殊的领域而并非完全的对象。 
- 最后，如果能避免使用多个锁，甚至写出无锁的线程安全程序是再好不过了。

## 8、什么是原子操作，Java中的原子操作是什么？
原子操作是不可分割的操作，一个原子操作中间是不会被其他线程打断的，多个原子操作合并起来后就不是一个原子操作了，就需要同步了。
i++不是一个原子操作，它包含 读取-修改-写入 操作，在多线程状态下是不安全的。
java内存模型允许将64位的读操作或写操作分解为2个32位的操作，所以对long和double类型的单次读写操作并不是原子的，注意使用volitile使他们成为原子操作。

## 9、Java中的volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？
 volatile关键字的作用是：保证变量的可见性。
 在java内存结构中，每个线程都是有自己独立的内存空间(此处指的线程栈)。当需要对一个共享变量操作时，线程会将这个数据从主存空间复制到自己的独立空间内进行操作，然后在某个时刻将修改后的值刷新到主存空间。
 volatile保证读取数据时只从主存空间读取，修改数据直接修改到主存空间中去，这样就保证了这个变量对多个操作线程的可见性了。换句话说，被volatile修饰的变量，能保证该变量的 单次读或者单次写 操作是原子的。
 线程安全是两方面需要的 原子性(指的是多条操作)和可见性。volatile只能保证可见性，synchronized是两个均保证的。

## 10、什么是竞态条件 (race condition)？你怎样发现和解决的？
一个简单的例子：错误的单例模式
```java
public class LazyInitRace {
    private ExpensiveObject instance = null;
    public ExpensiveObject getInstance() {
        if (instance == null)
            instance = new ExpensiveObject();
        return instance;
    }
}
```
在多线程下，三个原子操作的组合并不是原子操作，不一定能返回正确值。

如何避免？
① 警惕复合操作，需要用同步的手段来保证原子性。 
② 使用本身是线程安全的类。

## 11、为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
 当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。
 new一个Thread，线程进入了新建状态；调用start()方法，线程进入了就绪状态，当分配到时间片后就可以开始运行了。start()会执行线程的相应准备工作，然后自动执行run()方法的内容。是真正的多线程工作。而直接执行run()方法，会把run方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，这并不是多线程工作。

## 12、Java中你怎样唤醒一个阻塞的线程？
 会抛出InterruptedException的方法：wait、sleep、join、Lock.lockInterruptibly等，针对这类方法，我们在线程内部处理好异常(要不完全内部处理，要不把这个异常抛出去)，然后就可以实现唤醒。 
 不会抛InterruptedException的方法：Socket的I/O、同步I/O、Lock.lock等。对于I/O类型，我们可以关闭他们底层的通道，比如Socket的I/O，关闭底层套接字，然后抛出异常处理就好了；比如同步I/O，关闭底层Channel然后处理异常。对于Lock.lock方法，我们可以改造成Lock.lockInterruptibly方法去实现。

## 13、在Java中CycliBarriar和CountdownLatch有什么区别？
CountDownLatch : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。countDown()和await()
CyclicBarrier : N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。 await()

## 14、什么是不可变对象，为什么String是不可变的？不可变对象对写并发应用有什么帮助？
不可变对象（immutable Objects）就是那些一旦被创建，它们的状态就不能被改变的Objects，每次对他们的改变都是产生了新的不可变对象。
 Immutable对象是线程安全的，可以不用被synchronize就在并发环境中共享。可以缓存起来重复使用。

## 15、你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？
多线程和并发程序中常遇到的有Memory-interface、竞争条件、死锁、活锁和饥饿。

## thread dump
kill -10 pid：可触发进程进行一次强制GC。

``` shell
/**
 * 线程名称：Thread-1
 * 编号：#12
 * 优先级：5
 * 系统优先级：0
 * jvm内部线程id：0x0000000018d49000
 * 对应系统线程id（NativeThread ID）：0x17b8
 * 线程状态：waiting for monitor entry [0x0000000019d7f000]（等待某个条件）
 * 线程详细状态：java.lang.Thread.State: BLOCKED 及之后所有
 */
"Thread-1" #12 prio=5 os_prio=0 tid=0x0000000018d49000 nid=0x17b8 waiting for monitor entry [0x0000000019d7f000]
/** 
 * 线程状态：阻塞
 * 等待锁：0x00000000d629b4d8 
 * 已经获得锁：0x00000000d629b4e8
 */
   java.lang.Thread.State: BLOCKED (on object monitor)
    at com.leo.interview.SimpleDeadLock$B.run(SimpleDeadLock.java:56)
    - waiting to lock <0x00000000d629b4d8> (a java.lang.Object)
        - locked <0x00000000d629b4e8> (a java.lang.Object)
```





```

```